- there should be a definite method for determining if a person is "valid",
i.e. does he exist, in the same room, is visible, and a host of other
settings. There should be a gerneal method for checking this.
- For example when dealing with
shopkeepers :
	-	get all items that fit the criteria
	-	in case of problem -> returns ItemException
	-	do coin check
	-	in case of problem -> move item back into person : Person.addItem(stuff)
	-	in case of OK -> start removing coins from persons account and
		move item into a new person inventory : Person.addItem(stuff)
possibilities: - do everything at once in the database
				- do selective stuff in the database, and reissue queries
					when necessary.
- rmeove Echo.java

- problem: gold, silver, copper should be fields belonging to a certain
character, reason: if they are implemented as separate items we could be
having a problem regarding providing exact change.
- problem: dropping money onto a room, getting money from a room
	- items or -> advantage: already implemented for the most part
			-> disadvantage: conversion to user.fields
	- fields -> advantage: the same as fields in the user
			-> disadvantage: can it be pickedup dropped correctly?
- problem: what if someone wants to have a NEW item called a "nice bronze
pirate coin"? We'd be in a whole lot of trouble when items are used instead
of fields.
- adding fields to a room regarding money is not very efficient, because
most rooms do not have money lying around. It would waste space. An obvious
solution would be to keep all money in the room object, but not in the
database. (Okay, so money will be lost when the game is reset, so what, it
was just lying around anyway)
Decision:
- character has gold,silver,copper fields that are stored in the database
- room has gold,silver,copper fields stored in the object
- room money is lost upon server crash
- room money is lost upon rooms reset
- room description should incorporate money
- Get and Drop and Give will have to be changed to incorporate special
	cases for money

The Whole Thing Is Utter Crap!
gold, silver, copper coins are items, same as any other. The fact that
shopkeepers do not have proper change is going to have to be taken instride.

computation:
golda, silvera, coppera me
goldb, silverb, copperb shopkeeper
goldi, silveri, copperi item

It's too bloody complicated, just create and delete items as necessary.
1. Translate all values of the item to copper (getValue()).
2. transfer copperi from me to shopkeeper
	addendum: if my copper depleted, delete 1 silver and add 10 copper, than
	try again.
	addendum: if my silver depleted, delete 1 gold and add 10 silver, than
	try again with the previous addendum.
silverb + silveri
coppera - copperi < 0
copperb + copperi

And Again It Is Too Complicated:  if I change everything to copper, the
shopkeeper is going to have his/her hands full with coppers which is not a
very good position. At a first attempt I managed to add over 900 copper
coins dammit!

transfer gold until gold finished or no more gold required else
transfer silver until silver finished or no more silver required else
transfer copper until copper finished or no more copper required else
if value>=10 change gold into silver else
if value>=1 change silver into copper

Better description would be+
1. is value>=100 + you have gold coins?
	transfer gold coins
2. is value>=10 + you have silver coins?
	transfer silver coins
3. is value>=1 + you have copper coins?
	transfer copper coins
4. no more copper coins
	a. no more silver coins
		get gold coin, change to silver coins
	b. yes more silver coins
		get silver coin, change to copper coins

item+ 1 2 1
inventoyr 1 3 0
0 3 0 
0 2 0
0 1 0


- item methods in itemsdb, transfer/drop/get are too specific.
  keep it geneeral as in add/delete.

Implementation
--------------

- I split up Database.java in different static objects, that request the
connection from Database.java in order to have some semblance of order. It
becomes difficult to find the correct method in a huge Database object.

- It is impossible at this time, due to memory requirements, to keep all
items as separate objects in memory. Therefore I've chosen to, with regards
to items, keep all access to the items on the database level and to not
perform any caching. For rooms and characters this should not be a problem,
as the characters will not exceed 20 in most cases and very few rooms are
normally used. 

- Addendum to the previous point: However, I feel having an item object
facilitates matters immensely, and I should make use of it. The one thing
that I need to remember than, is not to keep any of the item objects in
memory. I.e. have them garbage collected as soon as they leave scope, and
reissue a query to the database whenever the item has been garbage collected
and needs to be recreated.

- Second Addendum: I do, however, take the same approach with the item
definitions as with the rooms and characters. I assume that the
itemdefinitions will not grow exorbitantly, as in general a small amount of
items will be used in the game.

- It might be a good idea to periodically flush the cached rooms and cached
itemdefinitions though. Within time, the caching will take up quite a big part.

- It is not a good idea to keep "amount" with the items, because it provides
a logistical nightmare, and makes it impossible (or difficult) to provide
unique abilities to certain items.

- It is better to have different itemtables, for rooms/items/characters, in
order to keep the primary key as best as possible. When moving items from
the table over to another table, it is best to:
1. retrieve itemids
2. remove itemids from table (reserving itemids)
3. add itemids to another table

- Create some nice typesafe enumerated classes with specific behaviour
designed per instance. (HEME~ (HIMHER) (ETC)

- wielding and wearing are both stored in the wearing field. This is because
they are mutually exclusive. An item is either being wield (weld?) or being
worn. It could use a better name though.

Game Behaviour
--------------

- gold, silver and copper coins will be normal items. All values will be
counted using "copper". I.e. a copper coin is worth 1 copper coin. 1 silver
coin is worth 10 copper coins and 1 gold coin is worth 100 copper coins.

- When falling asleep, it is only possible for two commands to be used:
awaken or quit.

- Items and money, in most muds, seem to be available in great quantities.
This is in soo much a problem, that inflation makes everything generally
worthless. Possibilities to remedy this:
	- make worthless items easily obtainable, make valueable items rare
	- do not provide any mechanisms that "create" items. If no items are
	  created from scratch, no imbalance will be perpetrated. New items,
	  however, could be created using resources at ones disposal.
	  (fish, gloves, nice chair, etc.) However, make certain that it
	  takes a great amount of time and effort to correctly create a new 
	  item.
	- do not make shopkeepers accept all items, only those items they are
	  interested in, and then only if they haven't completely filled up
	  their stock yet. It is even possible to have shopkeepers decide to set
	  the price depending on the amount they have in stock.

- Destruction of items can take place:
	- items can be consumed by
		- eating
		- drinking
		- fire
		- "use" in general
		- time (i.e. wear/tear/perishables/etc)

- Items can change fundamentally. Certain items can change into different
items, for example a "new torch" can change into a "burnt stick".

- In order for characters to have special abilities that require additional
database information, we are unable at this time to add them using the
"attributes". It will require a different interface to be implemented on top
of the default Character class. A good example is ShopKeeper.

- Searching for items, using the command "search", should be implemented by
examining INSIDE other items. So, say, "search shrubbery", it means that we
examine what is INSIDE the shrubbery, and take the first object that we come
across. In other words, a shrubbery is an item that can contain other items
but cannot be picked up like a bag.

- All mutations and administration of everything inside the database is
going to take place using PHP. It is the most secure solution.

- Items can contain items. An item that can contain items is called a
container. Containers are identified in two ways:
1. a specific iteminstance has an attribute called "container" (boolean,true)
2. an item definition has "container" set to value other than 0.

TODO
----

- Add 'plurals' to the items. (bucket -> buckets)
- logging is split up into the different characters. This makes it easier to
debug in a production environment.


Changes to the database
-----------------------

- changes " valuable" to "valuable" for 36,37,38.
- update mm_items set description = replace(description,
"http://www.karchan.org/","/") where description like "%karchan.org%";
- added help for eyebrow command
- alter table mm_rooms add (area varchar(49) not null default "Main");    
- create table mm_area (area varchar(49) not null primary key, description
text not null, shortdesc varchar(255) not null, owner varchar(20) , creation
timestamp);
- insert into mm_area values("Main", "The Land of Karchan is split up onto
different areas. This is the main area, and the area that is used by new
characters for exploring and learning about the way the game works.", "The
Main Area of Karchan", "Karn", null);
- create table mm_log (creation timestamp not null, name varchar(20) not
null, message varchar(255) not null, primary key (creation, name, message));
- update mm_usertable set password=password(password)

Creating a dupe database
------------------------

delete from mm_admin;
delete from mm_bantable;
delete from mm_charattributes;
delete from mm_charitemtable;
delete from mm_itemattributes;
delete from mm_itemitemtable;
delete from mm_items;
delete from mm_itemtable;
delete from mm_log;
delete from mm_logonmessage;
delete from mm_mailtable;
delete from mm_roomattributes;
delete from mm_roomitemtable;
delete from mm_rooms;
delete from mm_shopkeeperitems;
delete from mm_sillynamestable;
delete from mm_unbantable;
delete from mm_usertable;

insert into mm_bantable
select * 
from mud.bantable;
insert into mm_items
select *, null, now() 
from mud.items;
insert into mm_logonmessage
select *
from mud.logonmessage;
insert into mm_mailtable
select *
from mud.mailtable;
insert into mm_rooms
select *, null, now(), "Main"
from mud.rooms;
insert into mm_sillynamestable
select *
from mud.sillynamestable;
insert into mm_unbantable
select *
from mud.unbantable;
insert into mm_usertable
select *, null, now()
from mud.usertable;

setting roomitems
-----------------
insert into mm_itemtable
(itemid, creation, owner)
select (id, now(), null)
from mud.tmp_itemtable
where id < 0;

insert into mm_roomitemtable
(id, room, search)
select mm_itemtable.id, tmp.room, null
from mm_itemtable, mud.tmp_itemtable as tmp
where tmp.room <> 0 and (tmp.search = null or tmp.search = "");

retrieving someones inventory
-----------------------------
amount multiplied with ...
insert into mm_itemtable
(itemid, creation, owner)
select (id, now(), null)
from mud.tmp_itemtable
where belongsto = ?;

insert into mm_charitemtable
(id, belongsto)
select id, ?
from mm_itemtable
where id > x
